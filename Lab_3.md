# Проект №2  
## Проектирование распределённой системы (System Design)

### Тема проекта  
**Микроблог (аналог Twitter), MVP-версия**

## Постановка задачи

Целью работы является проектирование архитектуры распределённой информационной системы для сервиса микроблогов, позволяющего пользователям публиковать короткие сообщения и просматривать ленту публикаций пользователей, на которых они подписаны.

## Основной функционал системы

В рамках MVP реализация функционала:

- регистрация и аутентификация пользователей;
- публикация текстовых сообщений (постов);
- подписка на других пользователей;
- формирование персональной ленты новостей;
- (опционально) отправка уведомлений о новых постах.

Функции лайков, комментариев, репостов и поиска не входят в MVP и могут быть реализованы в дальнейшем.

## Нефункциональные требования

Нефункциональные требования:

- система должна корректно работать при росте количества пользователей;
- чтение ленты должно выполняться быстрее, чем запись (read-heavy нагрузка);
- система должна допускать горизонтальное масштабирование;
- отказ одного компонента не должен приводить к полной недоступности сервиса.

## Оценка предполагаемой нагрузки

Предполагаемые значения нагрузки:
- Количество пользователей (MAU): до 10 000
- Активные пользователи в день (DAU): ~2 000
- Среднее количество постов в день: ~20 000
- Среднее количество запросов ленты: 50 000–100 000 в день

Характер нагрузки — преимущественно read-heavy, так как операции чтения ленты выполняются значительно чаще, чем операции записи.
По этой причине в архитектуре используется кеширование (Redis) для ускорения выдачи данных.


## Общая архитектура системы

Компоненты:

- клиентское приложение (web / mobile);
- балансировщик нагрузки;
- API-шлюз (backend);
- логические сервисы:
  - сервис аутентификации;
  - сервис пользователей;
  - сервис постов;
  - сервис формирования ленты;
  - сервис уведомлений;
- системы хранения данных;
- кэш;
- очередь сообщений.

Все взаимодействия между клиентом и сервером происходят по HTTP(S).

## Логическая модель данных

### Пользователи (USERS)
- id (PK)
- username
- email
- password_hash
- created_at

### Посты (POSTS)
- id (PK)
- author_id (FK → USERS.id)
- content
- created_at

### Подписки (FOLLOWS)
- follower_id (FK → USERS.id)
- followee_id (FK → USERS.id)

Для ускорения выборок используются индексы по полям:
- POSTS(author_id, created_at)
- FOLLOWS(follower_id)


### Схема 1 — Общая архитектура системы
<img width="1172" height="282" alt="Архитектура" src="https://github.com/user-attachments/assets/01785170-813f-4483-ac04-3add8668ef40" />

### Схема 2 — Работа ленты
<img width="121" height="511" alt="Поток работы ленты2" src="https://github.com/user-attachments/assets/82cd7b8f-36e6-4468-ac5c-8d2164067c89" />


## Основные сценарии работы

### Сценарий: создание поста
1. Пользователь отправляет запрос через клиентское приложение.
2. Запрос поступает в API Gateway.
3. API Gateway проверяет авторизацию через Auth Service.
4. Запрос передаётся в Post Service.
5. Post Service сохраняет пост в базе данных.
6. Событие о создании поста отправляется в очередь сообщений.
7. Notification Service обрабатывает событие и отправляет уведомления подписчикам.

### Сценарий: получение ленты
1. Пользователь запрашивает ленту.
2. Запрос поступает в Feed Service через API Gateway.
3. Feed Service проверяет наличие данных в кеше (Redis).
4. При cache-hit данные возвращаются сразу.
5. При cache-miss данные загружаются из базы данных и сохраняются в кеш.
6. Сформированная лента возвращается пользователю.

## Обоснование выбора технологий

- **PostgreSQL** используется как основная СУБД благодаря поддержке транзакций,
  строгой схемы данных и надёжности.
- **Redis** применяется для кеширования ленты пользователей и уменьшения нагрузки
  на основную базу данных.
- **Очередь сообщений** используется для асинхронной обработки уведомлений,
  что позволяет не блокировать основные пользовательские запросы.
- **Микросервисная архитектура** упрощает масштабирование и изоляцию ответственности
  между компонентами системы.

## Высоконагруженный сценарий работы системы

Наиболее высоконагруженным сценарием для микроблогинг-сервиса является
формирование пользовательской ленты новостей.

Данный сценарий относится к категории read-heavy, так как:
- большинство пользователей чаще читают ленту, чем публикуют посты;
- при открытии приложения лента запрашивается автоматически;
- один пользователь может обновлять ленту многократно в течение короткого времени.

### Описание high-load сценария: получение ленты

1. Пользователь открывает приложение или обновляет ленту.
2. Клиент отправляет запрос в API Gateway.
3. API Gateway перенаправляет запрос в Feed Service.
4. Feed Service сначала обращается к Redis для получения закешированной ленты.
5. При cache-hit данные возвращаются пользователю без обращения к основной БД.
6. При cache-miss Feed Service запрашивает данные у Post Service и User Service.
7. Полученные данные агрегируются, сохраняются в Redis и возвращаются пользователю.

Использование кеширования позволяет:
- значительно снизить нагрузку на основную базу данных;
- уменьшить время ответа системы;
- обеспечить стабильную работу при большом количестве одновременных запросов.

### Схема 3 — Работа high-load сценария
<img width="701" height="398" alt="Под нагрузкой3" src="https://github.com/user-attachments/assets/1a832355-9a69-4377-80a5-8d797a7dcfb3" />


## Надёжность и масштабирование

- Все сервисы могут масштабироваться горизонтально.
- API Gateway обеспечивает единый вход и базовую защиту.
- Аутентификация реализуется с использованием токенов (JWT).
- Возможна настройка rate limiting для защиты от злоупотреблений.

## Выводы

В рамках лабораторной работы была спроектирована архитектура микроблогинг-сервиса.
Система построена с использованием микросервисного подхода, кеширования и асинхронных
взаимодействий.

Предложенное решение соответствует требованиям MVP, обеспечивает масштабируемость
и может служить основой для дальнейшего развития системы.

# Проект №2  
## Проектирование распределённой системы (System Design)

### Тема проекта  
**Маркетплейс (аналог Ozon/Wildberries), MVP: рекомендательная система на главной странице**

## Постановка задачи

Целью работы является проектирование архитектуры распределённой информационной системы для маркетплейса, а именно блока рекомендаций товаров на главной странице для покупателей.

В рамках MVP требуется обеспечить:
- быструю выдачу блока “Рекомендации” при открытии главной страницы;
- персонализацию на основе действий пользователя (просмотры/клики/корзина/покупки);
- устойчивость к высокой нагрузке (read-heavy);
- отказоустойчивость при падении части инфраструктуры (в том числе дата-центра).

## Основной функционал системы (MVP)

В рамках MVP реализуются функции именно рекомендательного блока:

- получение персональных рекомендаций товаров для пользователя на главной странице;
- логирование действий пользователя (просмотры, клики по карточкам, добавления в корзину, покупки) для улучшения рекомендаций;
- фильтрация рекомендаций по доступности товара (в наличии/нет в наличии);
- кеширование результатов рекомендаций для ускорения выдачи;

Функции полноценных заказов, оплат, доставки, поиска, отзывов и т.д. не входят в рамки данного MVP и рассматриваются как внешние контуры.

## Нефункциональные требования

- система должна корректно работать при росте количества пользователей и запросов;
- главная страница должна отрабатываться быстро; большинство запросов — чтение (read-heavy);
- система должна допускать горизонтальное масштабирование сервисов;
- отказ одного компонента не должен приводить к полной недоступности выдачи рекомендаций;

## Оценка предполагаемой нагрузки

Предполагаемые значения нагрузки:
- Количество пользователей (MAU): до 50 000
- Активные пользователи в день (DAU): ~10 000
- Среднее число открытий главной страницы: 3–5 раз в день на пользователя
- Запросов рекомендаций в день: 30 000–50 000
- Пиковая нагрузка: вечерние часы

Характер нагрузки — преимущественно read-heavy:
- выдача рекомендаций выполняется значительно чаще, чем пересчёт моделей/признаков;
- одни и те же рекомендации запрашиваются многократно (особенно у активных пользователей).

По этой причине в архитектуре используется кеширование (Redis) и асинхронная обработка событий.

## Общая архитектура системы

Компоненты:

- клиентское приложение (web / mobile);
- глобальный балансировщик нагрузки (DNS/LB);
- API-шлюз (API Gateway);
- логические сервисы:
  - Recommendation Service — выдача рекомендаций;
  - Catalog Service — данные о товарах (название, фото, категория);
  - Inventory Service — наличие товара;
  - Event Collector — сбор пользовательских событий (клик/просмотр/покупка);
  - Feature/Model Worker — асинхронное обновление признаков и пересчёт рекомендаций;
- системы хранения данных;
- кэш (Redis);
- очередь сообщений (для событий).

Все взаимодействия между клиентом и сервером происходят по HTTP(S).
Внутренние взаимодействия между сервисами возможны как HTTP/gRPC.

## Логическая модель данных

### Пользователи (USERS)
- id (PK)
- email / phone
- created_at

### Товары (PRODUCTS)
- id (PK)
- title
- category_id
- price
- created_at

### Остатки (INVENTORY)
- product_id
- stock_count
- updated_at

### События поведения (USER_EVENTS)
- id (PK)
- user_id
- event_type (view / click / add_to_cart / purchase)
- product_id
- created_at

### Кеш рекомендаций (в Redis)
- key: rec:{user_id}
- value: список product_id (и/или готовые карточки)
- ttl: 5–30 минут

Для ускорения выборок применяются индексы:
- USER_EVENTS(user_id, created_at)
- INVENTORY(product_id)
- PRODUCTS(category_id)

### Схема 1 — Общая архитектура
<img width="639" height="591" alt="Архитектура1_маркетплейс_без_фона" src="https://github.com/user-attachments/assets/12f4608f-45ee-4e4f-9f04-a5a7f1d3fc58" />




## Основные сценарии работы

### Сценарий: открытие главной страницы (получение рекомендаций)
1. Пользователь открывает главную страницу.
2. Запрос поступает в Global Load Balancer.
3. LB направляет запрос в доступный дата-центр.
4. Запрос проходит через API Gateway.
5. API Gateway маршрутизирует запрос в Recommendation Service.
6. Recommendation Service проверяет наличие рекомендаций в Redis:
   - при cache-hit выдаёт результат сразу;
   - при cache-miss формирует рекомендации из БД/сервисов и сохраняет в Redis.
7. Recommendation Service обращается к Catalog Service (карточки товаров).
8. Recommendation Service обращается к Inventory Service (проверка наличия).
9. Итоговый список рекомендаций возвращается пользователю.

### Сценарий: пользователь взаимодействует с товарами (сбор событий)
1. Пользователь смотрит товар / кликает карточку / добавляет в корзину / покупает.
2. Клиент отправляет событие в Event Collector (через API Gateway).
3. Event Collector пишет событие в БД событий (USER_EVENTS) и/или публикует в очередь.
4. Feature/Model Worker читает события из очереди и обновляет признаки/рекомендации.
5. Результат пересчёта может обновлять кеш рекомендаций для пользователя (rec:{user_id}).

### Схема 2 — Поток выдачи рекомендаций (cache-hit и cache-miss)
<img width="639" height="591" alt="рекомендации2_маркетплейс" src="https://github.com/user-attachments/assets/75b9e26d-f8e2-4a08-8d20-be1780df1cbd" />


## Обоснование выбора технологий

- **PostgreSQL** используется как основная СУБД для хранения данных товаров/пользователей/событий в рамках MVP благодаря поддержке транзакций, строгой схеме и надёжности
- **Redis** применяется для кеширования рекомендаций на пользователя и уменьшения нагрузки на основную БД (ускоряет read-heavy сценарий “главная страница”)
- **Очередь сообщений** (например Kafka) используется для асинхронной обработки событий поведения и обновления рекомендаций вне критического пути пользовательского запроса
- **Микросервисная архитектура** упрощает масштабирование ключевых компонентов (Recommendation Service, Event Collector) и изоляцию ответственности

## Высоконагруженный сценарий работы системы

Сценарий относится к read-heavy, так как:
- главная страница открывается очень часто;
- рекомендации запрашиваются автоматически;
- большинство пользователей чаще смотрят, чем совершают покупки.

### Описание high-load сценария: выдача рекомендаций на главной

1. Пользователь открывает приложение.
2. Клиент отправляет запрос в API Gateway.
3. API Gateway перенаправляет запрос в Recommendation Service.
4. Recommendation Service обращается к Redis по ключу rec: user_id.
5. При cache-hit рекомендации возвращаются без обращения к основной БД.
6. При cache-miss сервис получает кандидатов из БД/сервисов (Catalog/Inventory),
   формирует список и сохраняет его в Redis с TTL.
7. Итог возвращается клиенту.

Использование кеширования позволяет:
- снизить нагрузку на БД;
- уменьшить время ответа;
- обеспечить стабильную работу при большом количестве одновременных запросов.

### Схема 3 — Работа high-load сценария под нагрузкой
<img width="908" height="517" alt="высоконагруженный контур_3_маркетплейс" src="https://github.com/user-attachments/assets/541154fa-ad1f-46c9-b7e4-9d70d3c46326" />
В высоконагруженном сценарии открытие главной страницы обрабатывается по принципу cache-first:
Recommendation Service сначала читает готовый список рекомендаций из Redis. При cache-hit система
возвращает результат без обращения к БД, что снижает задержку и повышает пропускную способность.

Персонализация обеспечивается асинхронным контуром: пользовательские события (просмотры/клики)
собираются Event Collector и публикуются в очередь сообщений. Worker обрабатывает события,
обновляет признаки и инвалидацию/обновление кеша рекомендаций, не блокируя пользовательский запрос.


## Отказоустойчивость и сценарий отказа дата-центра

Система (в рамках проекта) размещается в двух дата-центрах (DC1 и DC2).
Цель — сохранить доступность выдачи рекомендаций при потере одного дата-центра и минимизировать потерю данных.

### Размещение компонентов
- Stateless-компоненты (API Gateway, Recommendation Service, Catalog/Inventory API) запускаются в обоих DC.
- Redis используется только как кеш рекомендаций. Потеря Redis ухудшает скорость и увеличивает нагрузку, но не приводит к потере исходных данных.
- PostgreSQL является источником данных. Для отказоустойчивости используется репликация.

### Репликация PostgreSQL
Выбран вариант: Основной (Primary) в DC1 + резервный (Replica) в DC2.
- Primary принимает записи.
- Replica получает изменения через WAL/streaming replication.
- При отказе DC1 выполняется failover: реплика в DC2 становится новым Primary.

Режим репликации для MVP: async (может быть минимальная потеря последних транзакций в случае отказа DC1).

### Что происходит при отказе одного DC(DC1)

#### Если DC1 недоступен:
1. Глобальный балансировщик переключает трафик на DC2.
2. Сервисы в DC2 продолжают обслуживать запросы.
3. Реплика PostgreSQL в DC2 повышается до основной (failover).
4. Redis-кеш в DC1 теряется, в DC2 продолжает работу.
5. Выдача рекомендаций продолжается, возможно с понижением качества (больше cache-miss).

Если позже DC1 возвращается:
- Он становится вторичным (Standby) и догоняет данные репликацией.
- После синхронизации возможно плановое переключение (failback).

#### Если DC2 недоступен:
- Primary в DC1 продолжает обслуживать записи и чтение.
- Потери данных нет, но снижается отказоустойчивость до восстановления DC2.

### Схема 4 — Демонстрация отказа DC и поведения данных


## Надёжность и масштабирование

- Recommendation Service и API Gateway масштабируются горизонтально.
- Redis снижает нагрузку на БД и ускоряет выдачу.
- Асинхронная обработка событий (очередь) позволяет пересчитывать рекомендации вне критического пути.
- Возможна настройка rate limiting на API Gateway для защиты от злоупотреблений.
- При деградации компонентов система может включать fallback: показывать “популярные товары” вместо персонализации.

---

## Выводы

В рамках лабораторной работы была спроектирована архитектура рекомендательного блока маркетплейса.
Система построена с использованием микросервисного подхода, кеширования и асинхронной обработки событий.
Решение соответствует требованиям MVP, ориентировано на read-heavy нагрузку и предусматривает отказоустойчивость
при потере одного дата-центра.
